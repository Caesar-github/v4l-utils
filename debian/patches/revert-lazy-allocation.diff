Description: Revert patch for lazy mmap buffer allocation
Forwarded: not-needed
Origin: upstream, http://git.linuxtv.org/cgit.cgi/v4l-utils.git/commit/?id=10213c975afdfcc90aa7de39e66c40cd7e8a57f7
Bug-Debian: http://bugs.debian.org/763433
Author: Gregor Jasny <gjasny@googlemail.com>

--- a/lib/libv4l2/libv4l2-priv.h
+++ b/lib/libv4l2/libv4l2-priv.h
@@ -31,6 +31,7 @@
    be adjusted! */
 #define V4L2_MAX_NO_FRAMES 32
 #define V4L2_DEFAULT_NREADBUFFERS 4
+#define V4L2_FRAME_BUF_SIZE (4096 * 4096)
 #define V4L2_IGNORE_FIRST_FRAME_ERRORS 3
 #define V4L2_DEFAULT_FPS 30
 
@@ -87,8 +88,6 @@
 	int first_frame;
 	struct v4lconvert_data *convert;
 	unsigned char *convert_mmap_buf;
-	size_t convert_mmap_buf_size;
-	size_t convert_mmap_frame_size;
 	/* Frame bookkeeping is only done when in read or mmap-conversion mode */
 	unsigned char *frame_pointers[V4L2_MAX_NO_FRAMES];
 	int frame_sizes[V4L2_MAX_NO_FRAMES];
--- a/lib/libv4l2/libv4l2.c
+++ b/lib/libv4l2/libv4l2.c
@@ -94,48 +94,6 @@
 };
 static int devices_used;
 
-static int v4l2_ensure_convert_mmap_buf(int index)
-{
-	long page_size;
-
-	if (devices[index].convert_mmap_buf != MAP_FAILED) {
-		return 0;
-	}
-
-	page_size = sysconf(_SC_PAGESIZE);
-	if (page_size < 0) {
-		int saved_err = errno;
-		V4L2_LOG_ERR("unable to retrieve page size\n");
-		errno = saved_err;
-		return -1;
-	}
-
-	/* round up to full page size */
-	devices[index].convert_mmap_frame_size =
-		(((devices[index].dest_fmt.fmt.pix.sizeimage + page_size - 1) /
-		page_size) * page_size);
-
-	devices[index].convert_mmap_buf_size =
-		devices[index].convert_mmap_frame_size * devices[index].no_frames;
-
-	devices[index].convert_mmap_buf = (void *)SYS_MMAP(NULL,
-			devices[index].convert_mmap_buf_size,
-			PROT_READ | PROT_WRITE,
-			MAP_ANONYMOUS | MAP_PRIVATE,
-			-1, 0);
-
-	if (devices[index].convert_mmap_buf == MAP_FAILED) {
-		devices[index].convert_mmap_frame_size = 0;
-		devices[index].convert_mmap_buf_size = 0;
-
-		int saved_err = errno;
-		V4L2_LOG_ERR("allocating conversion buffer\n");
-		errno = saved_err;
-		return -1;
-	}
-
-	return 0;
-}
 
 static int v4l2_request_read_buffers(int index)
 {
@@ -360,8 +318,7 @@
 				&devices[index].src_fmt, &devices[index].dest_fmt,
 				devices[index].frame_pointers[buf->index],
 				buf->bytesused, dest ? dest : (devices[index].convert_mmap_buf +
-					buf->index * devices[index].convert_mmap_frame_size),
-				dest_size);
+					buf->index * V4L2_FRAME_BUF_SIZE), dest_size);
 
 		if (devices[index].first_frame) {
 			/* Always treat convert errors as EAGAIN during the first few frames, as
@@ -570,7 +527,7 @@
 		buf->index = 0;
 
 	buf->m.offset = V4L2_MMAP_OFFSET_MAGIC | buf->index;
-	buf->length = devices[index].convert_mmap_frame_size;
+	buf->length = V4L2_FRAME_BUF_SIZE;
 	if (devices[index].frame_map_count[buf->index])
 		buf->flags |= V4L2_BUF_FLAG_MAPPED;
 	else
@@ -780,8 +737,6 @@
 	devices[index].nreadbuffers = V4L2_DEFAULT_NREADBUFFERS;
 	devices[index].convert = convert;
 	devices[index].convert_mmap_buf = MAP_FAILED;
-	devices[index].convert_mmap_buf_size = 0;
-	devices[index].convert_mmap_frame_size = 0;
 	for (i = 0; i < V4L2_MAX_NO_FRAMES; i++) {
 		devices[index].frame_pointers[i] = MAP_FAILED;
 		devices[index].frame_map_count[i] = 0;
@@ -855,11 +810,9 @@
 				V4L2_LOG_WARN("v4l2 mmap buffers still mapped on close()\n");
 		} else {
 			SYS_MUNMAP(devices[index].convert_mmap_buf,
-					devices[index].convert_mmap_buf_size);
+					devices[index].no_frames * V4L2_FRAME_BUF_SIZE);
 		}
 		devices[index].convert_mmap_buf = MAP_FAILED;
-		devices[index].convert_mmap_buf_size = 0;
-		devices[index].convert_mmap_frame_size = 0;
 	}
 	v4lconvert_destroy(devices[index].convert);
 	free(devices[index].readbuf);
@@ -913,10 +866,8 @@
 	   v4l2_unrequest_read_buffers may change the no_frames, so free the
 	   convert mmap buffer */
 	SYS_MUNMAP(devices[index].convert_mmap_buf,
-			devices[index].convert_mmap_buf_size);
+			devices[index].no_frames * V4L2_FRAME_BUF_SIZE);
 	devices[index].convert_mmap_buf = MAP_FAILED;
-	devices[index].convert_mmap_buf_size = 0;
-	devices[index].convert_mmap_frame_size = 0;
 
 	if (devices[index].flags & V4L2_STREAM_CONTROLLED_BY_READ) {
 		V4L2_LOG("deactivating read-stream for settings change\n");
@@ -1385,12 +1336,23 @@
 		/* An application can do a DQBUF before mmap-ing in the buffer,
 		   but we need the buffer _now_ to write our converted data
 		   to it! */
-		result = v4l2_ensure_convert_mmap_buf(index);
-		if (result)
-			break;
+		if (devices[index].convert_mmap_buf == MAP_FAILED) {
+			devices[index].convert_mmap_buf = (void *)SYS_MMAP(NULL,
+				(size_t)(devices[index].no_frames * V4L2_FRAME_BUF_SIZE),
+				PROT_READ | PROT_WRITE,
+				MAP_ANONYMOUS | MAP_PRIVATE,
+				-1, 0);
+			if (devices[index].convert_mmap_buf == MAP_FAILED) {
+				saved_err = errno;
+				V4L2_LOG_ERR("allocating conversion buffer\n");
+				errno = saved_err;
+				result = -1;
+				break;
+			}
+		}
 
 		result = v4l2_dequeue_and_convert(index, buf, 0,
-				devices[index].convert_mmap_frame_size);
+						  V4L2_FRAME_BUF_SIZE);
 		if (result >= 0) {
 			buf->bytesused = result;
 			result = 0;
@@ -1615,7 +1577,7 @@
 	if (index == -1 ||
 			/* Check if the mmap data matches our answer to QUERY_BUF. If it doesn't,
 			   let the kernel handle it (to allow for mmap-based non capture use) */
-			start || length != devices[index].convert_mmap_frame_size ||
+			start || length != V4L2_FRAME_BUF_SIZE ||
 			((unsigned int)offset & ~0xFFu) != V4L2_MMAP_OFFSET_MAGIC) {
 		if (index != -1)
 			V4L2_LOG("Passing mmap(%p, %d, ..., %x, through to the driver\n",
@@ -1640,16 +1602,26 @@
 		goto leave;
 	}
 
-	if (v4l2_ensure_convert_mmap_buf(index)) {
-		errno = EINVAL;
-		result = MAP_FAILED;
-		goto leave;
+	if (devices[index].convert_mmap_buf == MAP_FAILED) {
+		devices[index].convert_mmap_buf = (void *)SYS_MMAP(NULL,
+			(size_t)(devices[index].no_frames * V4L2_FRAME_BUF_SIZE),
+			PROT_READ | PROT_WRITE,
+			MAP_ANONYMOUS | MAP_PRIVATE,
+			-1, 0);
+		if (devices[index].convert_mmap_buf == MAP_FAILED) {
+			int saved_err = errno;
+
+			V4L2_LOG_ERR("allocating conversion buffer\n");
+			errno = saved_err;
+			result = MAP_FAILED;
+			goto leave;
+		}
 	}
 
 	devices[index].frame_map_count[buffer_index]++;
 
 	result = devices[index].convert_mmap_buf +
-		buffer_index * devices[index].convert_mmap_frame_size;
+		buffer_index * V4L2_FRAME_BUF_SIZE;
 
 	V4L2_LOG("Fake (conversion) mmap buf %u, seen by app at: %p\n",
 			buffer_index, result);
@@ -1667,11 +1639,10 @@
 	unsigned char *start = _start;
 
 	/* Is this memory ours? */
-	if (start != MAP_FAILED) {
+	if (start != MAP_FAILED && length == V4L2_FRAME_BUF_SIZE) {
 		for (index = 0; index < devices_used; index++)
 			if (devices[index].fd != -1 &&
 					devices[index].convert_mmap_buf != MAP_FAILED &&
-					length == devices[index].convert_mmap_frame_size &&
 					start >= devices[index].convert_mmap_buf &&
 					(start - devices[index].convert_mmap_buf) % length == 0)
 				break;
@@ -1685,7 +1656,6 @@
 
 			/* Re-do our checks now that we have the lock, things may have changed */
 			if (devices[index].convert_mmap_buf != MAP_FAILED &&
-					length == devices[index].convert_mmap_frame_size &&
 					start >= devices[index].convert_mmap_buf &&
 					(start - devices[index].convert_mmap_buf) % length == 0 &&
 					buffer_index < devices[index].no_frames) {
